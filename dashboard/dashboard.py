# -*- coding: utf-8 -*-
"""Dashboard.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t2lbpC5QjgN7fb31f4czcXH0tSZXOKjc
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Load the data
all_data = pd.read_csv('/content/sample_data/all_data_merge.csv')

# Function to calculate delivery time
def calculate_delivery_time(data):
    data['order_delivered_customer_date'] = pd.to_datetime(data['order_delivered_customer_date'])
    data['order_estimated_delivery_date'] = pd.to_datetime(data['order_estimated_delivery_date'])
    data['delivery_time'] = (data['order_delivered_customer_date'] - data['order_estimated_delivery_date']).dt.days
    return data

# Function to calculate total sales and average price per category
def calculate_category_sales(data):
    category_sales = data.groupby('product_category_name_english')[['order_item_id', 'price']].agg({'order_item_id': 'sum', 'price': 'mean'}).reset_index()
    category_sales = category_sales.sort_values(by='order_item_id', ascending=False)
    return category_sales

# Function to calculate total sales and average price per category
def calculate_category_sales(data):
    category_sales = data.groupby('product_category_name_english')[['order_item_id', 'price']].agg({'order_item_id': 'sum', 'price': 'mean'}).reset_index()
    category_sales = category_sales.sort_values(by='order_item_id', ascending=False)
    return category_sales

# Function to visualize average price per category
def visualize_average_price(data):
    plt.figure(figsize=(12, 6))
    bars = sns.barplot(x='price', y='product_category_name_english', data=data[:20], hue='product_category_name_english', palette='muted', dodge=False)
    plt.title('Rata-rata Harga Produk per Kategori (Top 20)')
    plt.xlabel('Rata-rata Harga (R$)')
    plt.ylabel('Kategori Produk')

    # Add data labels on each bar
    for bar in bars.patches:
        plt.text(bar.get_width(), bar.get_y() + bar.get_height() / 2, f'{bar.get_width():.2f}', ha='left', va='center', color='black', fontsize=10)

    st.pyplot()

# Function to visualize total sales per category
def visualize_category_sales(data):
    plt.figure(figsize=(12, 6))
    bars = sns.barplot(x='order_item_id', y='product_category_name_english', data=data[:20], hue='product_category_name_english', palette='viridis', dodge=False)
    plt.title('Total Penjualan per Kategori Produk (Top 20)')
    plt.xlabel('Total Penjualan')
    plt.ylabel('Kategori Produk')

    # Add data labels inside each bar
    for bar in bars.patches:
        plt.text(bar.get_width() / 2, bar.get_y() + bar.get_height() / 2, f'{int(bar.get_width()):,}', ha='center', va='center', color='white')

    st.pyplot()

# Function to visualize delivery time distribution
def visualize_delivery_time(data):
    plt.figure(figsize=(10, 6))
    sns.histplot(data['delivery_time'], bins=30, kde=True, color='skyblue')
    plt.title('Distribution of Delivery Time (days)')
    plt.xlabel('Number of Days')
    plt.ylabel('Frequency')
    st.pyplot()

# Function to visualize top customer cities and states
def visualize_customer_distribution(data):
    # Customer city counts
    customer_city_counts = data['customer_city'].value_counts().reset_index()
    customer_city_counts.columns = ['Customer City', 'Number of Customers']
    top_10_customer_cities = customer_city_counts.head(10)

    # Customer state counts
    customer_state_counts = data['customer_state'].value_counts().reset_index()
    customer_state_counts.columns = ['Customer State', 'Number of Customers']

    # Plotting
    fig, axes = plt.subplots(2, 1, figsize=(12, 16))
    axes[0].bar(top_10_customer_cities['Customer City'], top_10_customer_cities['Number of Customers'], color='skyblue')
    axes[0].set_title('Top 10 Customer Cities')
    axes[0].set_xlabel('Customer City')
    axes[0].set_ylabel('Number of Customers')
    axes[0].tick_params(axis='x', rotation=45)

    axes[1].bar(customer_state_counts['Customer State'], customer_state_counts['Number of Customers'], color='skyblue')
    axes[1].set_title('Customer Distribution by State')
    axes[1].set_xlabel('Customer State')
    axes[1].set_ylabel('Number of Customers')
    axes[1].tick_params(axis='x', rotation=45)

    plt.tight_layout()
    st.pyplot()
# Function to visualize segmentation of customers based on purchased product categories
def visualize_segmentation():
    # Menghitung jumlah pembelian untuk setiap kategori produk dan negara bagian
    category_counts = all_data['product_category_name_english'].value_counts().head(20)
    state_counts = all_data['customer_state'].value_counts().head(20)

    # Filter data hanya untuk kategori produk dan negara bagian yang ada di 20 teratas
    final_data_filtered = all_data[all_data['product_category_name_english'].isin(category_counts.index)]
    final_data_filtered = all_data[all_data['customer_state'].isin(state_counts.index)]

    # Visualisasi segmentasi pelanggan berdasarkan kategori produk yang dibeli
    plt.figure(figsize=(12, 6))
    sns.countplot(x='product_category_name_english', hue='customer_state', data=final_data_filtered, palette='muted')
    plt.title('Segmentasi Pelanggan berdasarkan Kategori Produk (Top 20)')
    plt.xlabel('Kategori Produk')
    plt.ylabel('Jumlah Pembelian')
    plt.xticks(rotation=45)
    plt.legend(title='Negara Bagian Pelanggan')

    st.pyplot()

# Function to calculate RFM metrics
def calculate_rfm_metrics(data):
    # Convert 'order_purchase_timestamp' to datetime
    data['order_purchase_timestamp'] = pd.to_datetime(data['order_purchase_timestamp'])

    # Recency
    latest_date = data['order_purchase_timestamp'].max()
    rfm_recency = data.groupby('customer_id')['order_purchase_timestamp'].max().reset_index()
    rfm_recency['recency'] = (latest_date - rfm_recency['order_purchase_timestamp']).dt.days

    # Frequency
    rfm_frequency = data.groupby('customer_id')['order_id'].count().reset_index()
    rfm_frequency.columns = ['customer_id', 'frequency']

    # Monetary
    rfm_monetary = data.groupby('customer_id')['price'].sum().reset_index()
    rfm_monetary.columns = ['customer_id', 'monetary']

    # Merge RFM metrics
    rfm_data = pd.merge(pd.merge(rfm_recency, rfm_frequency, on='customer_id'), rfm_monetary, on='customer_id')

    return rfm_data

# Function to perform RFM analysis
def perform_rfm_analysis(data):
    # Calculate RFM metrics
    rfm_data = calculate_rfm_metrics(data)

    # Calculate quartiles for RFM metrics
    quartiles = rfm_data[['recency', 'frequency', 'monetary']].quantile(q=[0.25, 0.5, 0.75])

    # Function to assign quartile scores
    def rfm_score(x, c):
        if x <= quartiles[c][0.25]:
            return 1
        elif x <= quartiles[c][0.50]:
            return 2
        elif x <= quartiles[c][0.75]:
            return 3
        else:
            return 4

    # Calculate RFM scores
    rfm_data['R'] = rfm_data['recency'].apply(rfm_score, c='recency')
    rfm_data['F'] = rfm_data['frequency'].apply(rfm_score, c='frequency')
    rfm_data['M'] = rfm_data['monetary'].apply(rfm_score, c='monetary')

    # Combine RFM scores
    rfm_data['RFM_Score'] = rfm_data['R'].astype(str) + rfm_data['F'].astype(str) + rfm_data['M'].astype(str)

    return rfm_data

# Function to segment customers based on RFM scores
def segment_customers(rfm_data):
    # Define segment dictionary
    segment_dict = {
        '111': 'Best Customers',
        '311': 'Loyal Customers',
        '411': 'Big Spenders',
        '444': 'Lost Cheap Customers',
        '144': 'Almost Lost',
        '344': 'Recent Customers',
        '244': 'High-Spending New Customers',
        '133': 'Lowest Activity',
        '333': 'Mid-Spending Customers',
        '233': 'Low-Spending New Customers'
    }

    # Map segments
    rfm_data['Segment'] = rfm_data['RFM_Score'].map(segment_dict)

    return rfm_data

# Function to visualize RFM segments
def visualize_rfm_segments(rfm_data):
    # Segment counts
    segment_counts = rfm_data['Segment'].value_counts()

    # Plotting
    plt.figure(figsize=(10, 6))
    bars = segment_counts.plot(kind='bar', color='skyblue')
    plt.title('Segmentation of Customers')
    plt.xlabel('Segments')
    plt.ylabel('Number of Customers')
    plt.xticks(rotation=45, ha='right')

    # Displaying values on bars
    for bar in bars.patches:
        plt.text(bar.get_x() + bar.get_width() / 2, bar.get_height(),
                 f'{int(bar.get_height())}', ha='center', va='bottom')

    plt.tight_layout()
    st.pyplot()

# Main Streamlit app
def main():
    global all_data
    st.title('E-commerce Data Analysis')

    st.header('Delivery Time Analysis')
    all_data = calculate_delivery_time(all_data)
    visualize_delivery_time(all_data)

    st.header('Customer Distribution Analysis')
    visualize_customer_distribution(all_data)

    st.header('RFM Analysis and Customer Segmentation')
    rfm_data = perform_rfm_analysis(all_data)
    segmented_rfm_data = segment_customers(rfm_data)
    visualize_rfm_segments(segmented_rfm_data)

if __name__ == "__main__":
    main()